#!/usr/bin/env python

import xmmsclient
import xmmsclient.glib
from xmmsclient.consts import *
import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
import gobject

MPRIS = "org.mpris.xmms2"
MEDIAPLAYER = "org.freedesktop.MediaPlayer"

# The name reported to dbus
DBUS_CLIENTNAME = "XMMS2"
# The name reported to xmms2, only alphanumeric caracters
XMMS2_CLIENTNAME = 'MPRIS_connection'

NONE                 = 0
CAN_GO_NEXT          = 1 << 0
CAN_GO_PREV          = 1 << 1
CAN_PAUSE            = 1 << 2
CAN_PLAY             = 1 << 3
CAN_SEEK             = 1 << 4
CAN_PROVIDE_METADATA = 1 << 5
CAN_HAS_TRACKLIST    = 1 << 6

DBUS_PLAY  = 0
DBUS_PAUSE = 1
DBUS_STOP  = 2

#FIXME: Those three status informations are not yet implemented
DBUS_RANDOM_OFF = 0
DBUS_RANDOM_ON  = 1

DBUS_REPEAT_CURRENT_OFF = 0
DBUS_REPEAT_CURRENT_ON  = 1

DBUS_REPEAT_PL_OFF = 0
DBUS_REPEAT_PL_ON  = 1

# Helper Hack to make async calls to xmms2 possible,
# Used as I know of no way to store additional data in a XMMSResult
dbus_cb_func = {}

# Some general functions
def program_error (cb_func, Exception):
	cb_func ("Internal XMMS2-MPRIS error: " + str (Exception))

#TODO: Add additional fields as soon as xmms2 provides them
def convert_dict (dict):
	# location is mandatory, so no trying and catching
	ret_dict = {'location':dict['url']}

	key_list = ['title', 'artist', 'album', 'genre', 'comment' ]
	for key in key_list:
		try: ret_dict[key] = dict[key]
		except KeyError: pass

	# add later (mpris, xmms2): ('rating', ?), ('year', 'date'), ('date', ?)
	# ('arturl', ?)
	key_list = [('tracknumber', 'tracknr'), ('mtime', 'duration'), \
	            ('audio-bitrate', 'bitrate'), \
	            ('audio-samplerate', 'samplerate')]
	for mpris_key, xmms2_key in key_list:
		try: ret_dict[mpris_key] = dict[xmms2_key]
		except KeyError: pass

	try: ret_dict['time'] = dict['duration'] /1000
	except KeyError: pass

	return ret_dict




# MPRIS '/' handler class
class mpris_root (dbus.service.Object):
	def __init__ (self):
		dbus.service.Object.__init__ (self, dbus.SessionBus(), "/")

	@dbus.service.method (MEDIAPLAYER, in_signature='', out_signature='s')
	def Identity (self):
		return DBUS_CLIENTNAME

	@dbus.service.method (MEDIAPLAYER, in_signature='', out_signature='')
	def Quit (self):
		client.xmms2.quit ()

	@dbus.service.method (MEDIAPLAYER, in_signature='', out_signature='(qq)')
	def MprisVersion (self):
		return (1, 0)




# MPRIS "/TrackList" handler class
class mpris_TrackList (dbus.service.Object):
	def __init__ (self, xmms2):
		dbus.service.Object.__init__ (self, dbus.SessionBus(), "/TrackList")
		self.playlist = [] # will be set afterwards
		self.current_pos = 0
		self.active_name =""
		xmms2.playlist_current_active (self._cb_handle_pls_name)	
		xmms2.broadcast_playlist_loaded (cb=self._cb_handle_pls_name)
#		xmms2.playlist_list_entries (cb=self._cb_handle_playlist) #done in _cb_handle_pls_name
		xmms2.broadcast_playlist_changed (cb=self._cb_fetch_playlist)
#		xmms2.playlist_current_pos (cb=self._cb_handle_current_pos) # done in _cb_handle_playlist
		xmms2.broadcast_playlist_current_pos (cb=self._cb_handle_current_pos)

	# FIXME: doesn't work yet
	@dbus.service.method (MEDIAPLAYER, in_signature='i', out_signature='a{sv}', \
	                       async_callbacks=('cb_val', 'cb_err'))
	def GetMetadata (self, pos, cb_val, cb_err):
		res = client.xmms2.medialib_get_info (id=self.playlist[pos], cb=self._cb_GetMetadata)
		dbus_cb_func[res] = (cb_val, cb_err)

	def _cb_GetMetadata (self, res):
		cb_val, cb_err = dbus_cb_func.pop(res)
		try:
			cb_val (convert_dict (res.value ()))
		except Exception, err:
			cb_err (str (err))

	@dbus.service.method (MEDIAPLAYER, out_signature="i")
	def GetCurrentTrack (self):
		return self.current_pos

	@dbus.service.method (MEDIAPLAYER, out_signature="i")
	def GetLength (self):
		return len (self.playlist)

	#TODO:
	def AddTrack (self, uri, play_now):
		pass

	@dbus.service.method (MEDIAPLAYER, in_signature="i")
	def DelTrack (self, pos):
		client.xmms2.playlist_remove_entry (pos)

	#TODO
	@dbus.service.method (MEDIAPLAYER, in_signature="b")
	def SetLoop (self, loop):
		pass

	#TODO: currently not possible, because sorting won't work
	@dbus.service.method (MEDIAPLAYER, in_signature="b")
	def SetRandom (self, random):
		pass

	#Signals
	@dbus.service.signal (MEDIAPLAYER, signature='i')
	def TrackListChange (self, len):
		pass

	# Just fetch the complete playlist whenever it might have canged.
	# This could be optimized, but I'll leave that for sometime later
	def _cb_fetch_playlist (self, res):
		client.xmms2.playlist_list_entries (cb=self._cb_handle_playlist)	

	def _cb_handle_playlist (self, res):
		list = res.value ()		
		# This method is also called if another playlist is loaded.
		# We handle playlists with the same entries as the same playlist,
		# even if their names differ
		client.xmms2.playlist_current_pos (cb=self._cb_handle_current_pos)
		if (self.playlist != list):	
			self.playlist = list
			self.TrackListChange (len (list))

	def _cb_handle_pls_name (self, res):
		name = res.value ()
		if self.active_name != name:
			self.active_name = name
			client.xmms2.playlist_list_entries (cb=self._cb_handle_playlist)
			

	def _cb_handle_current_pos (self, res):
		pos_d = res.value ()
		if self.active_name == pos_d['name']:
			self.current_pos = pos_d['position']


# MPRIS "/Player" handler class
class mpris_Player (dbus.service.Object):
	# TODO: react to streams: CAN_SEEK = false, CAN_PAUSE = false 
	def __init__ (self, xmms2):
		dbus.service.Object.__init__ (self, dbus.SessionBus(), "/Player")
		self.onechannel = False # TODO: initialize correctly on stratup
		self.current_id = 0 # This is also returned by xmms2 if no song is currently set
		self.playstatus = DBUS_STOP
		self.randomplay = DBUS_RANDOM_OFF
		self.current_repeat = DBUS_REPEAT_CURRENT_OFF
		self.pl_repeat = DBUS_REPEAT_PL_OFF
		# CAN_SEEK, CAN_PROVIDE_METADATA, CAN_HAS_TRACKLIST will be handled later,
		# CAN_PAUSE and CAN_PLAY will also need to be handled according to plystatus
		self.caps = CAN_GO_NEXT | CAN_GO_PREV | CAN_PAUSE | CAN_PLAY \
		          | CAN_HAS_TRACKLIST
		xmms2.playback_current_id (cb=self._cb_current_id)
		xmms2.broadcast_playback_current_id (cb=self._cb_current_id)
		xmms2.broadcast_medialib_entry_changed (cb=self._cb_entry_changed)
		xmms2.playback_status (cb=self._cb_playback_status)
		xmms2.broadcast_playback_status (cb=self._cb_playback_status)

	@dbus.service.method (MEDIAPLAYER)
	def Next (self):
		client.xmms2.playlist_set_next_rel (1)
		client.xmms2.playback_tickle ()

	@dbus.service.method (MEDIAPLAYER)
	def Pref (self):
		client.xmms2.playlist_set_next_rel (-1)
		client.xmms2.playback_tickle ()

	@dbus.service.method (MEDIAPLAYER)
	def Pause (self):
		client.xmms2.playback_pause ()

	@dbus.service.method (MEDIAPLAYER)
	def Stop (self):
		client.xmms2.playback_stop ()

	@dbus.service.method (MEDIAPLAYER)
	def Play (self):
		client.xmms2.playback_start ()

	#TODO
	@dbus.service.method (MEDIAPLAYER, in_signature='b')
	def Repeat(self, repeat):
		return False

	@dbus.service.method (MEDIAPLAYER, out_signature='(iiii)')
	def GetStatus(self):
		return self.build_status ()


	@dbus.service.method (MEDIAPLAYER, out_signature='a{sv}',
	                      async_callbacks=('cb_val', 'cb_err'))
	def GetMetadata(self, cb_val, cb_err):
		ret = client.xmms2.medialib_get_info (self.current_id, \
		                                      self._cb_GetMetadata)
		dbus_cb_func[ret] = (cb_val, cb_err)

	def _cb_GetMetadata (self, ret):
		cb_val, cb_err = dbus_cb_func.pop (ret)
		try:
			dict = ret.value ()
			if (dict == None):
				cb_val ({})
				return
			cb_val (convert_dict (dict))
		except Exception, err:
			program_error (cb_err, err)


	@dbus.service.method (MEDIAPLAYER, out_signature='i')
	def GetCaps (self):
		return self.caps

	@dbus.service.method (MEDIAPLAYER, in_signature='i')
	def VolumeSet (self, volume):
		if (self.onechannel):
			client.xmms2.playback_volume_set ("master", volume)
		else:
			client.xmms2.playback_volume_set ("left", volume)
			client.xmms2.playback_volume_set ("right", volume)


	@dbus.service.method (MEDIAPLAYER, out_signature='i',
	                      async_callbacks=('cb_val', 'cb_err'))
	def VolumeGet (self, cb_val, cb_err):
		res = client.xmms2.playback_volume_get (self._cb_VolumeGet)
		dbus_cb_func[res] = (cb_val, cb_err)

	def _cb_VolumeGet (self, res):
		cb_val, cb_err = dbus_cb_func.pop (res)
		try:
			res = res.value ()
			if (res.has_key ('master')):
				self.onechannel = True
				cb_val (res['master'])
			else:
				self.onechannel = False
				cb_val ((res['left']+res['right'])/2)
		except KeyError:
			cb_err("could not get volume, volume keys: " + str(res.keys ()))
		except Exception, err:
			program_error (cb_err, err)


	@dbus.service.method (MEDIAPLAYER, in_signature='i')
	def PositionSet (self, mtime):
		client.xmms2.playback_seek_ms (mtime)


	@dbus.service.method (MEDIAPLAYER, out_signature='i',
	                      async_callbacks=('cb_val', 'cb_err'))
	def PositionGet (self, cb_val, cb_err):
		res = client.xmms2.playback_playtime (self._cb_PositionGet)
		dbus_cb_func[res] = (cb_val, cb_err)

	def _cb_PositionGet (self, res):
		cb_val, cb_err = dbus_cb_func.pop(res)
		try:
			cb_val (res.value ())
		except Exception, err:
			program_error (cb_err, err)

	#Signals
	@dbus.service.signal (MEDIAPLAYER, signature='a{sv}')
	def TrackChange (self, var):
		pass

	@dbus.service.signal (MEDIAPLAYER, signature='(iiii)')
	def StatusChange (self, data):
		pass

	@dbus.service.signal (MEDIAPLAYER, signature='i')
	def CapsChange (self, caps):
		pass

	# class-internal helpers
	def build_status (self):
		return (self.playstatus, self.randomplay, self.current_repeat, self.pl_repeat)

	# Callbacks emitting used for emitting the dbus signals
	def _cb_current_id (self, res):
		self.current_id = res.value ()
		if self.current_id < 1:
			# mlib id 0 means that no entry is selected, so we also have no metadata 
			if self.caps & CAN_PROVIDE_METADATA:
				self.caps &= ~CAN_PROVIDE_METADATA
				self.CapsChange (self.caps)
			return
		if (~self.caps) & CAN_PROVIDE_METADATA:
			self.caps |= CAN_PROVIDE_METADATA
			self.CapsChange (self.caps)
		client.xmms2.medialib_get_info (self.current_id, self._cb_mlib_data)

	def _cb_entry_changed (self, res):
		if (self.current_id == res.value ()):
			client.xmms2.medialib_get_info (self.current_id, self._cb_mlib_data)

	def _cb_mlib_data (self, res):
		res = res.value ()
		self.TrackChange (convert_dict (res))

	def _cb_playback_status (self, res):
		status = res.value ()
		# TODO: Modify CAN_PLAY and CAN_PAUSE
		if (status == PLAYBACK_STATUS_STOP) and (self.playstatus != DBUS_STOP):
			self.playstatus = DBUS_STOP
			self.StatusChange (self.build_status ()) 
		elif (status == PLAYBACK_STATUS_PLAY) and (self.playstatus != DBUS_PLAY):
			self.playstatus = DBUS_PLAY
			self.StatusChange (self.build_status ())
		elif (status == PLAYBACK_STATUS_PAUSE) and (self.playstatus != DBUS_PAUSE):
			self.playstatus = DBUS_PAUSE	
			self.StatusChange (self.build_status ())
			

class Xmms2MPRIS:
	def __init__(self):
		# The glib mainloop is used to glue the xmms2 and the dbus connection
		# together, because they both provide their own mainloop and I'm
		# too lazy to write a sprecial connector
		self.ml = gobject.MainLoop(None, False)
		self.xmms2 = xmmsclient.XMMS(XMMS2_CLIENTNAME)
		#connect to the xmms2 server, it should be running as it started us
		#TODO: perhaps this could make use of a bi more error handling
		try:
			self.xmms2.connect(disconnect_func = self._on_server_quit)
		except IOError, detail:
			print 'Connection failed:', detail
			sys.exit(1)
		self.xmmsconn = xmmsclient.glib.GLibConnector(self.xmms2)

		self.dbusconn = DBusGMainLoop(set_as_default=True)
		dbus.SessionBus().request_name (MPRIS);

		self.mpris_root = mpris_root ()
		self.mpris_tracklist = mpris_TrackList (self.xmms2)
		self.mpris_player = mpris_Player (self.xmms2)

	def	_on_server_quit(self, result):
		self.ml.quit ()


client = Xmms2MPRIS()
client.ml.run ()
